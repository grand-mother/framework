# -*- coding: utf-8 -*-
"""
Initialiser for GRAND packages

Copyright (C) 2018 The GRAND collaboration

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
"""

import argparse
import os
import shutil
import subprocess
import sys

from distutils.spawn import find_executable
from setuptools import setup, find_packages
from setup import parse_readme

__all__ = [ "main" ]


def get_data_dir():
    """Get the absolute path to the package data files"""
    path = os.path.dirname(__file__)
    path = os.path.join(path, "data")
    return os.path.abspath(path)


def copy(data_dir, target_dir, file_):
    """Copy a file out of the data folder to a target directory"""
    dst = os.path.join(target_dir, file_)
    if not os.path.exists(dst):
        src = os.path.join(data_dir, file_)
        shutil.copyfile(src, dst)

def mkdir(path):
    """Create directories recursively if they don't exist"""
    if not os.path.exists(path):
        os.makedirs(path)


def write_readme(path, git_name, dist_name, title, description):
    """Write a default README file"""

    content = """\
# {title:}
_{description:}_

## Description

<!-- Add here a description of the package -->


## Installation

The latest stable version of this package can be installed from [PyPi][PYPI]
using [pip][PIP], e.g. as:
```bash
pip install --user {dist_name:}
```

Alternatively one can also install the latest development commit directly from
[GitHub][GITHUB], as:
```bash
pip install --user git+https://github.com/grand-mother/{git_name:}.git@master
```


## License

The GRAND software is distributed under the LGPL-3.0 license. See the provided
[`LICENSE`][LICENSE] and [`COPYING.LESSER`][COPYING] files.


[COPYING]: https://github.com/grand-mother/{git_name:}/blob/master/COPYING.LESSER
[GITHUB]: https://github.com/grand-mother/{git_name:}
[LICENSE]: https://github.com/grand-mother/{git_name:}/blob/master/LICENSE
[PIP]: https://pypi.org/project/pip
[PYPI]: https://pypi.org/project/{dist_name:}
""".format(
        title=title, description=description, git_name=git_name,
        dist_name=dist_name)

    with open(path, "w") as f:
        f.write(content)


def write_source(path, description):
    """Write a default __init__.py file"""

    content = '''\
# -*- coding: utf-8 -*-
"""
{:}

Copyright (C) 2018 The GRAND collaboration

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
"""

# This is generated by the GRAND framework in order to track the package
# version. DO NOT DELETE.
try:
    from .version import __version__, __githash__
except ImportError:
    __version__ = None
    __githash__ = None

# Import here any public module(s)
'''.format(description)

    with open(path, "w") as f:
        f.write(content)


def write_setup(path):
    """Write a default setup.py file for the base package"""

    content = """\
# -*- coding: utf-8 -*-

from framework import setup_package


# The package version
MAJOR = 0
MINOR = 0
MICRO = 0


# Extra package meta data can be added here. For a full list of available
# classifiers, see:
#     https://pypi.org/pypi?%3Aaction=list_classifiers
EXTRA_CLASSIFIERS = (
    "Development Status :: 1 - Planning",
)


if __name__ == "__main__":
    setup_package(
        # Framework arguments
        __file__, (MAJOR, MINOR, MICRO), EXTRA_CLASSIFIERS,

        # Vanilla setuptools.setup arguments can be added below,
        # e.g. `entry_points` for executables or `data_files`
    )
"""

    with open(path, "w") as f:
        f.write(content)


def write_tests_init(path, package_name):
    """Write a default __init__.py file for the tests package"""

    content = '''\
# -*- coding: utf-8 -*-
"""
Unit tests for the {:} package
"""
'''.format(package_name)

    with open(path, "w") as f:
        f.write(content)


def write_tests_main(path, package_name):
    """Write a default __main__.py file for the tests package"""

    content = '''\
# -*- coding: utf-8 -*-
"""
Run all unit tests for the {:} package
"""
import os
import unittest


def suite():
    test_loader = unittest.TestLoader()
    path = os.path.dirname(__file__)
    test_suite = test_loader.discover(path, pattern="test_*.py")
    return test_suite


if __name__ == "__main__":
    unittest.TextTestRunner(verbosity=2).run(suite())
'''.format(package_name)

    with open(path, "w") as f:
        f.write(content)


def write_tests_version(path, package_name):
    """Write a default test_version.py file for the tests package"""

    content = '''\
# -*- coding: utf-8 -*-
"""
Unit tests for the {0:}.version module
"""

import unittest
import sys

import {0:}
from framework import git


class VersionTest(unittest.TestCase):
    """Unit tests for the version module"""

    def test_hash(self):
        githash, _ = git("rev-parse", "HEAD")
        self.assertEqual(githash.strip(), {0:}.version.__githash__)

    def test_version(self):
        self.assertIsNotNone({0:}.version.__version__)


if __name__ == "__main__":
    unittest.main()
'''.format(package_name)

    with open(path, "w") as f:
        f.write(content)


def add_git_hook(git_dir, hook_name):
    """Add a hook for managing git workflow"""

    exe_name = "grand-git-" + hook_name
    exe_path = find_executable(exe_name)
    if not exe_path:
        msg = ( "Warning: could not locate " + exe_name,
                "  Hook has not been installed",
                "")
        sys.stderr.write(os.linesep.join(msg))
        return False

    path = os.path.join(git_dir, "hooks", hook_name)
    try:
        os.remove(path)
    except OSError:
        pass
    os.symlink(exe_path, path)
    return True


def main():
    """Parse CLI arguments and initialise a local package"""

    parser = argparse.ArgumentParser(description='Initialise a GRAND package.')
    parser.add_argument(
        "path", type = str, nargs = "?", default = ".",
        help = "the path to the package")
    parser.add_argument(
        "--default", dest = "use_default", action = "store_const",
        const = True, default = False, help = "use default options")
    parser.add_argument(
        "--quiet", dest = "quiet", action = "store_const",
        const = True, default = False, help = "suppress output")
    args = parser.parse_args()

    # Set system calls
    def quiet_system(cmd):
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=True)
        p.communicate()

    system = quiet_system if args.quiet else os.system

    # Path to the package data
    data_dir = get_data_dir()

    # Set the package top directory
    package_dir = os.path.abspath(args.path)
    mkdir(package_dir)

    # Add static file, e.g. licensing
    copy(data_dir, package_dir, "LICENSE")
    copy(data_dir, package_dir, "COPYING.LESSER")
    copy(data_dir, package_dir, "MANIFEST.in")
    copy(data_dir, package_dir, ".gitignore")
    copy(data_dir, package_dir, ".travis.yml")

    # Initialise the docs
    docs_dir = os.path.join(package_dir, "docs")
    mkdir(docs_dir)

    path = os.path.join(docs_dir, "README.md")
    if not os.path.exists(path):
        # Get the package name from any existing source
        packages = find_packages(package_dir, exclude=("tests",))
        if len(packages) == 1:
            default_name = packages[0]
        else:
            default_name = os.path.basename(package_dir).replace("-", "_")

        # Prompt the package meta data
        if args.use_default:
            package_name = default_name
        else:
            prompt = "Please enter the package name [{:}]: ".format(
                default_name)
            package_name = raw_input(prompt).strip()
            if not package_name:
                package_name = default_name
        if not package_name:
            if not args.quiet:
                print("Aborting ...")
            sys.exit(0)

        default_description = "Add a brief description"
        if args.use_default:
            description = default_description
        else:
            prompt = "Please enter a brief description: "
            description = raw_input(prompt).strip()
            if not description:
                description = default_description 

        git_name = package_name.replace("_", "-")
        if git_name.startswith("grand-"):
            dist_name = git_name
        else:
            dist_name = "grand-" + git_name

        # Write a default README
        title = package_name.replace("_", " ").replace("-", " ").capitalize()
        write_readme(path, git_name, dist_name, title, description)
    else:
        package_name, _, meta = parse_readme(path)
        description = meta["description"]

    # Initialise the source
    src_dir = os.path.join(package_dir, package_name)
    mkdir(src_dir)

    path = os.path.join(src_dir, "__init__.py")
    if not os.path.exists(path):
        write_source(path, description)

    # Initialise the tests
    tests_dir = os.path.join(package_dir, "tests")
    mkdir(tests_dir)

    path = os.path.join(tests_dir, "__init__.py")
    if not os.path.exists(path):
        write_tests_init(path, package_name)

    path = os.path.join(tests_dir, "__main__.py")
    if not os.path.exists(path):
        write_tests_main(path, package_name)

    path = os.path.join(tests_dir, "test_version.py")
    if not os.path.exists(path):
        write_tests_version(path, package_name)

    # Initialise the setup script
    path = os.path.join(package_dir, "setup.py")
    if not os.path.exists(path):
        write_setup(path)

    # Initialise git
    git_dir = os.path.join(package_dir, ".git")
    if not os.path.exists(git_dir):
        system("git init " + package_dir)
        commit = True
    else:
        commit = False

    # Add hooks for git
    code = 0
    if not add_git_hook(git_dir, "pre-commit"): code = 1
    if not add_git_hook(git_dir, "prepare-commit-msg"): code = 1

    # Do the initial commit
    if commit:
        command = ["cd " + package_dir]
        files = (
            ".gitignore", ".travis.yml", "COPYING.LESSER", "LICENSE",
            "MANIFEST.in", "docs/README.md", "setup.py", "tests",
            package_name
        )
        for file_ in files:
            command.append("git add " + file_)
        command.append("git commit -m 'Initial commit'")
        system(" && ".join(command))

    # Exit to the OS
    sys.exit(code)


if __name__ == "__main__":
    main()
