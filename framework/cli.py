# -*- coding: utf-8 -*-
"""
Command line interface for GRAND packages

Copyright (C) 2018 The GRAND collaboration

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
"""

import argparse
import json
import os
import shutil
import subprocess
import sys

from distutils.spawn import find_executable
from setuptools import setup, find_packages
from . import PKG_FILE, PKG_PREFIX

try:
    input = input
except:
    pass

__all__ = [ "main" ]


_DEFAULT_DESCRIPTION = "Add a brief description"
"""Default description for GRAND packages"""


def get_data_dir():
    """Get the absolute path to the package data files"""
    path = os.path.dirname(__file__)
    path = os.path.join(path, "data")
    return os.path.abspath(path)


def copy(data_dir, target_dir, file_, force=False):
    """Copy a file out of the data folder to a target directory"""
    dst = os.path.join(target_dir, file_)
    if force or not os.path.exists(dst):
        src = os.path.join(data_dir, file_)
        shutil.copyfile(src, dst)

def mkdir(path):
    """Create directories recursively if they don't exist"""
    if not os.path.exists(path):
        os.makedirs(path)


def write_coverage_config(path, package_name):
    """Write a default config file for `coverage`"""

    content = """\
[run]
branch = True
include = */{:}/*.py

[report]
exclude_lines =
    if self.debug:
    pragma: no cover
    raise NotImplementedError
    except ImportError:
    if __name__ == .__main__.:
ignore_errors = True
omit =
    tests/*
    setup.py
""".format(package_name)

    with open(path, "w") as f:
        f.write(content)


def write_readme(path, git_name, dist_name, title, description):
    """Write a default README file"""

    content = """\
# {title:}
_{description:}_

## Description

<!-- Add here a description of the package -->


## Installation

_GRAND packages require python3.7. If can be installed from the
[tarball](https://www.python.org/downloads) on Linux or with brew on OSX._

The latest stable version of this package can be installed from [PyPi][PYPI]
using [pip][PIP], e.g. as:
```bash
pip3 install --user {dist_name:}
```

Alternatively one can also install the latest development commit directly from
[GitHub][GITHUB], as:
```bash
pip3 install --user git+https://github.com/grand-mother/{git_name:}.git@master
```


## License

The GRAND software is distributed under the LGPL-3.0 license. See the provided
[`LICENSE`][LICENSE] and [`COPYING.LESSER`][COPYING] files.


[COPYING]: https://github.com/grand-mother/{git_name:}/blob/master/COPYING.LESSER
[GITHUB]: https://github.com/grand-mother/{git_name:}
[LICENSE]: https://github.com/grand-mother/{git_name:}/blob/master/LICENSE
[PIP]: https://pypi.org/project/pip
[PYPI]: https://pypi.org/project/{dist_name:}
""".format(
        title=title, description=description, git_name=git_name,
        dist_name=dist_name)

    with open(path, "w") as f:
        f.write(content)


def write_source(path, description):
    """Write a default __init__.py file"""

    content = '''\
# -*- coding: utf-8 -*-
"""
{:}

Copyright (C) 2018 The GRAND collaboration

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
"""

# This is generated by the GRAND framework in order to track the package
# version. DO NOT DELETE.
try:
    from .version import __version__, __githash__
except ImportError:
    __version__ = None
    __githash__ = None

# Initialise the package below
'''.format(description)

    with open(path, "w") as f:
        f.write(content)


def write_setup(path):
    """Write a default setup.py file for the base package"""

    content = """\
# -*- coding: utf-8 -*-

from framework import setup_package


# The package version
MAJOR = 0
MINOR = 0
MICRO = 0


# Extra package meta data can be added here. For a full list of available
# classifiers, see:
#     https://pypi.org/pypi?%3Aaction=list_classifiers
EXTRA_CLASSIFIERS = (
    "Development Status :: 1 - Planning",
)


if __name__ == "__main__":
    setup_package(
        # Framework arguments
        __file__, (MAJOR, MINOR, MICRO), EXTRA_CLASSIFIERS,

        # Vanilla setuptools.setup arguments can be added below,
        # e.g. `entry_points` for executables or `data_files`
    )
"""

    with open(path, "w") as f:
        f.write(content)


def write_tests_init(path, package_name):
    """Write a default __init__.py file for the tests package"""

    content = '''\
# -*- coding: utf-8 -*-
"""
Unit tests for the {:} package
"""
'''.format(package_name)

    with open(path, "w") as f:
        f.write(content)


def write_tests_main(path, package_name):
    """Write a default __main__.py file for the tests package"""

    content = '''\
# -*- coding: utf-8 -*-
"""
Run all unit tests for the {:} package
"""
import os
import unittest
import sys


def suite():
    test_loader = unittest.TestLoader()
    path = os.path.dirname(__file__)
    test_suite = test_loader.discover(path, pattern="test_*.py")
    return test_suite


if __name__ == "__main__":
    runner = unittest.TextTestRunner(verbosity=2)
    r = not runner.run(suite()).wasSuccessful()
    sys.exit(r)
'''.format(package_name)

    with open(path, "w") as f:
        f.write(content)


def write_tests_version(path, package_name):
    """Write a default test_version.py file for the tests package"""

    content = '''\
# -*- coding: utf-8 -*-
"""
Unit tests for the {0:}.version module
"""

import unittest
import sys

import {0:}
from framework import git


try:
    import {0:}.version
except:
    # Skip version tests for non release builds
    pass
else:
    class VersionTest(unittest.TestCase):
        """Unit tests for the version module"""

        def test_hash(self):
            githash = git("rev-parse", "HEAD")
            self.assertEqual(githash.strip(), {0:}.version.__git__["sha1"])

        def test_version(self):
            self.assertIsNotNone({0:}.version.__version__)


if __name__ == "__main__":
    unittest.main()
'''.format(package_name)

    with open(path, "w") as f:
        f.write(content)


def add_git_hook(git_dir, hook_name):
    """Add a hook for managing git workflow"""

    exe_name = PKG_PREFIX + hook_name
    exe_path = find_executable(exe_name)
    if not exe_path:
        msg = ( "Warning: could not locate " + exe_name,
                "  Hook has not been installed",
                "")
        sys.stderr.write(os.linesep.join(msg))
        return False

    path = os.path.join(git_dir, "hooks", hook_name)
    try:
        os.remove(path)
    except OSError:
        pass
    os.symlink(exe_path, path)
    return True


def init(args=None):
    """Initialise a bare GRAND package"""

    parser = argparse.ArgumentParser(
        description='Initialise a bare GRAND package.')
    parser.add_argument(
        "path", type = str, nargs = "?", default = ".",
        help = "the path to the package")
    parser.add_argument(
        "--default", dest = "use_default", action = "store_const",
        const = True, default = False, help = "use default options")
    parser.add_argument(
        "--quiet", dest = "quiet", action = "store_const",
        const = True, default = False, help = "suppress output")
    args = parser.parse_args(args)

    # Set system calls
    def quiet_system(cmd):
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE, shell=True)
        p.communicate()

    system = quiet_system if args.quiet else os.system

    # Path to the package data
    data_dir = get_data_dir()

    # Set the package top directory
    package_dir = os.path.abspath(args.path)
    if os.path.exists(package_dir):
        path = os.path.join(package_dir, PKG_FILE)
        if os.path.exists(path):
            if not args.quiet:
                print("Package already exists ...")
            sys.exit(1)
    else:
        mkdir(package_dir)

    # Add static file, e.g. licensing
    copy(data_dir, package_dir, "LICENSE", force=True)
    copy(data_dir, package_dir, "COPYING.LESSER", force=True)
    copy(data_dir, package_dir, "MANIFEST.in")
    copy(data_dir, package_dir, ".gitignore")
    copy(data_dir, package_dir, ".travis.yml", force=True)

    # Initialise the docs
    docs_dir = os.path.join(package_dir, "docs")
    mkdir(docs_dir)

    # Get the package name from any existing source
    packages = find_packages(package_dir, exclude=("tests",))
    if len(packages) == 1:
        default_name = packages[0].lower()
    else:
        default_name = os.path.basename(package_dir).replace("-", "_").lower()

    # Prompt the package meta data
    if args.use_default:
        package_name = default_name
    else:
        prompt = "Please enter the package name [{:}]: ".format(
            default_name)
        package_name = input(prompt).strip()
        if not package_name:
            package_name = default_name
    if not package_name:
        if not args.quiet:
            print("Aborting ...")
        sys.exit(0)
    elif package_name != package_name.lower():
        if not args.quiet:
            print("Package names must be lower case (pep8) ...")
        sys.exit(1)

    if args.use_default:
        description = _DEFAULT_DESCRIPTION
    else:
        prompt = "Please enter a brief description: "
        description = input(prompt).strip()
        if not description:
            description = default_description 

    git_name = package_name.replace("_", "-")
    if git_name.startswith("grand-"):
        dist_name = git_name
    else:
        dist_name = "grand-" + git_name

    # Write a default README
    path = os.path.join(docs_dir, "README.md")
    if not os.path.exists(path):
        title = package_name.replace("_", " ").replace("-", " ").capitalize()
        write_readme(path, git_name, dist_name, title, description)

    # Write the configuration file for `coverage`
    path = os.path.join(package_dir, ".coveragerc")
    if not os.path.exists(path):
        write_coverage_config(path, package_name)

    # Initialise the source
    src_dir = os.path.join(package_dir, package_name)
    mkdir(src_dir)

    path = os.path.join(src_dir, "__init__.py")
    if not os.path.exists(path):
        write_source(path, description)

    # Initialise (or update) the tests
    tests_dir = os.path.join(package_dir, "tests")
    mkdir(tests_dir)

    path = os.path.join(tests_dir, "__init__.py")
    if not os.path.exists(path):
        write_tests_init(path, package_name)

    path = os.path.join(tests_dir, "__main__.py")
    write_tests_main(path, package_name)

    path = os.path.join(tests_dir, "test_version.py")
    write_tests_version(path, package_name)

    # Initialise the setup script
    path = os.path.join(package_dir, "setup.py")
    if not os.path.exists(path):
        write_setup(path)

    # Initialise git
    git_dir = os.path.join(package_dir, ".git")
    if not os.path.exists(git_dir):
        system("git init " + package_dir)
        commit = True
    else:
        commit = False

    # Add hooks for git
    code = 0
    if not add_git_hook(git_dir, "pre-commit"): code = 1
    if not add_git_hook(git_dir, "prepare-commit-msg"): code = 1

    # Dump the initial stats.
    path = os.path.join(package_dir, PKG_FILE)
    if not os.path.exists(path):
        with open(path, "w") as f:
            json.dump({"package": {"name": package_name, "git-name": git_name,
                                   "dist-name": dist_name}}, f)

    # Do the initial commit
    if commit:
        command = ["cd " + package_dir]
        files = (
            ".coveragerc", ".gitignore", ".travis.yml", "COPYING.LESSER",
            "LICENSE", "MANIFEST.in", "docs/README.md", "setup.py", "tests",
            package_name
        )
        for file_ in files:
            command.append("git add " + file_)
        command.append("git commit -m 'Initial commit'")
        system(" && ".join(command))

    # Exit to the OS
    sys.exit(code)


def _parse_readme(package_dir):
    """Parse some meta data from the README.md"""

    path = os.path.join(package_dir, "docs/README.md")
    meta = {"description": _DEFAULT_DESCRIPTION}
    package_name = None
    with open(path, "r") as f:
        for line in f:
            if line.startswith("#"):
                package_name = line[1:].strip().lower().replace(" ", "_")
            elif package_name is not None:
                meta["description"] = line.replace("_", " ").strip()
                break

    if package_name is None:
        return None

    git_name = package_name.replace("_", "-")
    if git_name.startswith("grand-"):
        dist_name = git_name
    else:
        dist_name = "grand-" + git_name

    meta["name"] = package_name
    meta["git-name"] = git_name
    meta["dist-name"] = dist_name

    return meta


def update(args=None):
    """Update a GRAND package"""

    parser = argparse.ArgumentParser(
        description='Update a GRAND package.')
    parser.add_argument(
        "path", type = str, nargs = "?", default = ".",
        help = "the path to the package")
    parser.add_argument(
        "--quiet", dest = "quiet", action = "store_const",
        const = True, default = False, help = "suppress output")
    args = parser.parse_args(args)

    # Set system calls
    def system(cmd):
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE, shell=True)
        out, err = p.communicate()
        if err:
            if not args.quiet:
                print(err.decode("utf-8"))
            sys.exit(1)
        return out.decode("utf-8")

    # Check for an update
    user = "" if hasattr(sys, "real_prefix") else "--user" # Hack for virtualenv
    out = system("pip3 install {:} --upgrade grand-framework".format(user))
    if not out.startswith("Requirement already up-to-date: grand-framework"):
        print(out)

    # Set the package top directory
    update_data = False
    package_dir = os.path.abspath(args.path)
    if os.path.exists(package_dir):
        path = os.path.join(package_dir, PKG_FILE)
        if not os.path.exists(path):
            update_data = True
            path = os.path.join(package_dir, ".stats.json")
            if not os.path.exists(path):
                if not args.quiet:
                    print("Not a GRAND package ...")
                sys.exit(1)
    else:
        if not args.quiet:
            print("Path does not exist ...")
        sys.exit(1)

    # Update static files, e.g. licensing
    data_dir = get_data_dir()

    copy(data_dir, package_dir, "LICENSE", force=True)
    copy(data_dir, package_dir, "COPYING.LESSER", force=True)
    copy(data_dir, package_dir, ".travis.yml", force=True)

    # Update the hooks for git
    git_dir = os.path.join(package_dir, ".git")
    code = 0
    if not add_git_hook(git_dir, "pre-commit"): code = 1
    if not add_git_hook(git_dir, "prepare-commit-msg"): code = 1

    # Check for old style meta
    with open(path, "r") as f:
        stats = json.load(f)

    if not "package" in stats:
        meta = _parse_readme(package_dir)
        if meta is None:
            if not args.quiet:
                print("Could not parse package data from the README ...")
            sys.exit(1)
        update_data = True
        stats["package"] = meta

    if update_data:
        old_path = os.path.join(package_dir, ".stats.json")
        if os.path.exists(old_path):
            system("git mv .stats.json " + PKG_FILE)
        path = os.path.join(package_dir, PKG_FILE)
        with open(path, "w") as f:
            json.dump(stats, f)
        system("git add " + PKG_FILE)

    # Exit to the OS
    sys.exit(code)


if __name__ == "__main__":
    # Get the function to call from the command line
    ret = globals()[sys.argv[1]](sys.argv[2:])
    if ret is not None:
        print(ret)
